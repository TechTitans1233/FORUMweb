<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Disaster Warning System – Mapa Híbrido</title>

  <link rel="stylesheet" href="../forum/forum.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css">

  <style>
    .hidden { display: none; }
    #map { height: 600px; width: 100%; }
    .info {
      background: white;
      color: #000;
      font-family: Arial, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      z-index: 1000;
      text-align: left;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 10px;
    }
    .info h4 {
      margin: 0;
      padding: 0;
      font-size: 16px;
      color: #333;
    }
    .info p {
      margin: 0; padding: 0;
    }
    .info a {
      color: #007BFF;
      text-decoration: none;
    }
    .info a:hover {
      text-decoration: underline;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.8);
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      z-index: 1001;
      display: none;
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Disaster Warning System</h1>
    </header>

    <aside id="user-menu">
      <div class="sidebar" id="sidebar">
        <ul>
          <li><a href="../forum/forum.html" class="button"><i class="fas fa-home"></i><span class="icon-text"> Início</span></a></li>
          <li><a href="../perfil/perfil.html" class="button"><i class="fas fa-user"></i><span class="icon-text"> Perfil</span></a></li>
          <li><a href="configuracoes.html" class="button"><i class="fas fa-cog"></i><span class="icon-text"> Configurações</span></a></li>
          <li><a href="notificacoes.html" class="button"><i class="fas fa-bell" id="notificacoes"></i><span class="icon-text"> Notificações</span></a></li>
          <li><a href="sair.html" class="button"><i class="fas fa-sign-out-alt"></i><span class="icon-text"> Sair</span></a></li>
        </ul>
      </div>
    </aside>

    <main id="main-content">
      <div id="map"></div>
      <div id="loading">Carregando dados...</div>
    </main>

    <aside id="community">
      <div class="info" id="info">
        <p>Passe o cursor sobre um evento para ver detalhes.</p>
      </div>
    </aside>

    <footer>
      <p>© 2024 Minha Rede Social. Todos os direitos reservados.</p>
    </footer>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // 1) Inicializa o mapa
      const map = L.map('map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);

      const infoDiv = document.getElementById('info');
      const loadingDiv = document.getElementById('loading');

      // 2) Função para atualizar a div de detalhes no hover
      function updateInfo(props) {
        if (props) {
          infoDiv.innerHTML = `
            <h4>${props.eventname || "Evento sem nome"}</h4>
            <p><strong>Categoria:</strong> ${props.eventtype || "Não disponível"}</p>
            <p><strong>Descrição:</strong> ${props.description || "Sem descrição"}</p>
            <p><strong>Impacto:</strong> ${props.alertlevel || "Não informado"}</p>
            <p><strong>Localização:</strong> ${props.localizacao || "—"}</p>
            <p><strong>Data:</strong> ${props.fromdate ? props.fromdate.split('T')[0] : "Não disponível"} 
                a ${props.todate ? props.todate.split('T')[0] : "Não disponível"}</p>
            <p><a href="${props.url?.report || '#'}" target="_blank">Mais detalhes</a></p>
          `;
        } else {
          infoDiv.innerHTML = '<p>Passe o cursor sobre um evento para ver detalhes.</p>';
        }
      }

      // 3) pointToLayer para os marcadores estáticos
      function pointToLayerStatic(feature, latlng) {
        const icon = L.icon({
          iconUrl: feature.properties.iconoverall || 'https://via.placeholder.com/32',
          iconSize: [32, 32],
          iconAnchor: [16, 16]
        });
        return L.marker(latlng, { icon: icon });
      }

      // 4) onEachFeature (comportamento de hover) igual para ambos
      function onEachFeature(feature, layer) {
        layer.on({
          mouseover: () => updateInfo(feature.properties),
          mouseout:  () => updateInfo()
        });
      }

      // ╔═ PARTE A: Carrega o GeoJSON fixo ══════════════════════════╗
      loadingDiv.style.display = 'block';
      fetch('result-3.geojson')
        .then(response => {
          if (!response.ok) throw new Error('Erro ao carregar o arquivo GeoJSON');
          return response.json();
        })
        .then(data => {
          L.geoJSON(data, {
            pointToLayer: pointToLayerStatic,
            onEachFeature: onEachFeature
          }).addTo(map);
        })
        .catch(error => {
          console.error('Erro ao carregar GeoJSON estático:', error);
          infoDiv.innerHTML = '<p>Erro ao carregar os dados estáticos.</p>';
        })
        .finally(() => {
          loadingDiv.style.display = 'none';
        });
      // ╚════════════════════════════════════════════════════════════╝

      // ╔═ PARTE B: Rotina EXTRA para buscar posts, classificar e adicionar marcadores/polígonos ══╗

      // Mapeamento de ícones com base na categoria e impacto
      const iconMap = {
        'VO': {
          'Orange': 'https://www.gdacs.org/images/gdacs_icons/maps/Orange/VO.png',
        },
        'EQ': {
          'Red': 'https://www.gdacs.org/images/gdacs_icons/maps/Red/EQ.png',
        },
        'TC': {
          'Green': 'https://www.gdacs.org/images/gdacs_icons/maps/Green/TC.png',
          'Red': 'https://www.gdacs.org/images/gdacs_icons/maps/Red/TC.png'
        }
      };

      // Ícone padrão para casos não mapeados
      const defaultIconUrl = 'https://via.placeholder.com/32';

      // Função para obter o ícone com base na categoria e impacto
      function getDynamicIcon(categoria, impacto) {
        const iconUrl = iconMap[categoria]?.[impacto] || defaultIconUrl;
        return L.icon({
          iconUrl: iconUrl,
          iconSize: [32, 32],
          iconAnchor: [16, 16],
          popupAnchor: [0, -16]
        });
      }

      async function buscarPublicacoes() {
        try {
          const response = await fetch('/api/publicacoes'); // Ajuste este endpoint conforme necessário
          if (!response.ok) throw new Error('Erro ao buscar publicações');
          const publicacoes = await response.json();
          console.log(`[DEBUG] Veio(n) ${publicacoes.length} publicação(ões) do /api/publicacoes`);
          return publicacoes.map(p => ({
            id: p.id,
            titulo: p.titulo,
            conteudo: p.conteudo,
            lat: p.lat,
            lon: p.lon,
            marcacao: p.marcacao // Adiciona o campo 'marcacao' aqui
          }));
        } catch (error) {
          console.error('[DEBUG] buscarPublicacoes:', error);
          return [];
        }
      }

      async function classificarMensagem(mensagem) {
        try {
          const response = await fetch("http://localhost:5000/predict", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ mensagem }),
          });
          if (!response.ok) {
            const erro = await response.json();
            throw new Error(erro.erro || "Erro na requisição de classificação");
          }
          return await response.json(); // { categoria, localizacao, impacto }
        } catch (error) {
          console.error('[DEBUG] classificarMensagem:', error);
          return { categoria: '—', localizacao: '—', impacto: '—' };
        }
      }

      async function carregarEventosDinamicos() {
        loadingDiv.style.display = 'block';
        const publicacoes = await buscarPublicacoes();

        if (publicacoes.length === 0) {
          console.warn('[DEBUG] Nenhuma publicação para processar.');
          loadingDiv.style.display = 'none';
          return;
        }

        const latLngArray = []; // Array para armazenar LatLngs para o fitBounds

        const promessas = publicacoes.map(async post => {
          console.log(`[DEBUG] Processando post ID=${post.id}`);
          
          let resultado = { categoria: '—', localizacao: '—', impacto: '—' };
          if (post.conteudo) {
            console.log(`[DEBUG] Classificando conteúdo:`, post.conteudo);
            resultado = await classificarMensagem(post.conteudo);
          }

          // Adiciona marcador se houver lat/lon válidos
          const latNum = parseFloat(post.lat);
          const lonNum = parseFloat(post.lon);

          if (!isNaN(latNum) && !isNaN(lonNum)) {
            latLngArray.push([latNum, lonNum]);
            // Usa o ícone correspondente à categoria e impacto
            const markerIcon = getDynamicIcon(resultado.categoria, resultado.impacto);
            const marker = L.marker([latNum, lonNum], { icon: markerIcon });
            const props = {
              eventname: post.titulo,
              eventtype: resultado.categoria,
              description: post.conteudo,
              localizacao: resultado.localizacao,
              alertlevel: resultado.impacto,
              fromdate: null,
              todate: null,
              url: { report: '#' },
              iconoverall: iconMap[resultado.categoria]?.[resultado.impacto] || defaultIconUrl
            };
            marker.on('mouseover', () => updateInfo(props));
            marker.on('mouseout', () => updateInfo());
            marker.addTo(map);
            console.log(`[DEBUG] Marcador para post ID=${post.id} adicionado com ícone: ${markerIcon.options.iconUrl}`);
          } else {
            console.warn(`[DEBUG] Coordenadas inválidas ou ausentes para post ID=${post.id}: lat='${post.lat}', lon='${post.lon}'`);
          }

          // --- Início da lógica para 'marcacao' GeoJSON (polígonos e outras geometrias) ---
          if (post.marcacao) {
            try {
              const marcacaoGeoJSON = JSON.parse(post.marcacao);

              // Propriedades para o hover, comuns a todas as geometrias de 'marcacao'
              const marcacaoProps = {
                eventname: post.titulo || "Área Demarcada",
                eventtype: resultado.categoria,
                description: post.conteudo || "Demarcação de área",
                localizacao: resultado.localizacao,
                alertlevel: resultado.impacto,
                fromdate: null,
                todate: null,
                url: { report: '#' },
                iconoverall: iconMap[resultado.categoria]?.[resultado.impacto] || defaultIconUrl
              };

              if (marcacaoGeoJSON && marcacaoGeoJSON.geometry && marcacaoGeoJSON.geometry.coordinates) {
                if (marcacaoGeoJSON.type === "Feature" && marcacaoGeoJSON.geometry.type === "Polygon") {
                  // Lógica específica para polígonos
                  const latLngs = marcacaoGeoJSON.geometry.coordinates[0].map(coord => [coord[1], coord[0]]);
                  const polygonLayer = L.polygon(latLngs, {
                    color: 'green',
                    weight: 3,
                    opacity: 0.8,
                    fillColor: 'yellow',
                    fillOpacity: 0.2
                  }).addTo(map);

                  polygonLayer.on('mouseover', () => updateInfo(marcacaoProps));
                  polygonLayer.on('mouseout', () => updateInfo());
                  polygonLayer.on('click', () => map.fitBounds(polygonLayer.getBounds()));

                  if (polygonLayer.getBounds().isValid()) {
                    latLngArray.push(polygonLayer.getBounds().getNorthEast());
                    latLngArray.push(polygonLayer.getBounds().getSouthWest());
                  }
                  console.log(`[DEBUG] Polígono para post ID=${post.id} adicionado.`);

                } else if (marcacaoGeoJSON.type === "Feature" && marcacaoGeoJSON.geometry.type === "Point") {
                  // Lógica para pontos em 'marcacao'
                  const [lon, lat] = marcacaoGeoJSON.geometry.coordinates;
                  latLngArray.push([lat, lon]);
                  const pointIcon = getDynamicIcon(resultado.categoria, resultado.impacto);
                  const pointMarker = L.marker([lat, lon], { icon: pointIcon }).addTo(map);
                  pointMarker.on('mouseover', () => updateInfo(marcacaoProps));
                  pointMarker.on('mouseout', () => updateInfo());
                  console.log(`[DEBUG] Ponto GeoJSON para post ID=${post.id} adicionado com ícone: ${pointIcon.options.iconUrl}`);
                } else {
                  // Lógica para outras geometrias GeoJSON (LineString, MultiPolygon, etc.)
                  const geoJsonLayer = L.geoJSON(marcacaoGeoJSON, {
                    style: {
                      color: 'blue',
                      weight: 3,
                      opacity: 0.7,
                      fillColor: 'cyan',
                      fillOpacity: 0.3
                    },
                    onEachFeature: function (feature, layer) {
                      layer.on('mouseover', () => updateInfo(marcacaoProps));
                      layer.on('mouseout', () => updateInfo());
                      if (layer.getBounds && layer.getBounds().isValid()) {
                        layer.on('click', () => map.fitBounds(layer.getBounds()));
                      }
                    }
                  }).addTo(map);

                  if (geoJsonLayer.getBounds().isValid()) {
                    latLngArray.push(geoJsonLayer.getBounds().getNorthEast());
                    latLngArray.push(geoJsonLayer.getBounds().getSouthWest());
                  }
                  console.log(`[DEBUG] GeoJSON (não polígono/punto) para post ID=${post.id} adicionado.`);
                }
              } else {
                console.warn(`[DEBUG] GeoJSON inválido ou incompleto para post ID=${post.id}:`, marcacaoGeoJSON);
              }
            } catch (e) {
              console.error(`[DEBUG] Erro ao analisar GeoJSON 'marcacao' para post ID=${post.id}:`, e);
            }
          }
          // --- Fim da lógica para 'marcacao' GeoJSON ---
        });

        await Promise.all(promessas);
        
        // Ajusta o mapa para caber todos os marcadores e polígonos (se houver pelo menos 1 coordenada válida)
        if (latLngArray.length > 0) {
          try {
            const bounds = L.latLngBounds(latLngArray);
            if (bounds.isValid()) {
              map.fitBounds(bounds.pad(0.2));
            } else {
              console.warn('[DEBUG] Limites calculados inválidos, não foi possível ajustar o mapa.');
            }
          } catch (e) {
            console.error('[DEBUG] Erro ao ajustar o mapa para os limites:', e);
          }
        }

        console.log(`[DEBUG] Processamento de eventos dinâmicos concluído.`);
        loadingDiv.style.display = 'none';
      }

      // Dispara a busca/classificação depois que a Parte A carrega
      carregarEventosDinamicos();
      // ╚══════════════════════════════════════════════════════════════╝

    });
  </script>
</body>
</html>